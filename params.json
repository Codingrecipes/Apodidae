{"name":"Apodidae","tagline":"Swift dependency Injection Framework","body":"# Apodidae #\r\n### Swift Dependency Injection Framework ###\r\n\r\nWith Swift 2.0 and [this talk ](https://developer.apple.com/videos/wwdc/2015/?id=408) from Apple,\r\nprotocol oriented programming has now arrived on the Cocoa scene.  Although protocols allow for\r\nelegant decoupling of interface from implementation, a little extra glue (in the form of \r\n[Dependecy Injection](http://www.martinfowler.com/articles/injection.html)) cements the ideal of\r\nnever having to know if your [duck is actually a duck](https://en.wikipedia.org/wiki/Duck_typing)\r\n\r\n### Name ###\r\n\r\n[Apodidae](https://en.wikipedia.org/wiki/Swift) is the taxonomic family of birds known as swifts\r\nin english.  Is your swift a sooty swift or a lesser swallow tail swift?  You don't care! that's\r\nwhy you're using dependency injection, obviously...\r\n\r\n### Usage ###\r\n\r\nHave a protocol that needs filling? add `Injectable` to your implementation:\r\n```swift\r\nprotocol Swift {\r\n  func airspeedVelocity() -> Int\r\n}\r\n\r\nstruct WhiteThroatedNeedleTail: Swift, Injectable {\r\n  static func dependencies -> [Any] {\r\n    return []\r\n  }\r\n  \r\n  init(dependencies: [Injectable]) {}\r\n  \r\n  func airspeedVelocity() -> Int {\r\n    return 169\r\n  }\r\n}\r\n```    \r\nand register with the registrar:\r\n```swift\r\nimport Apodidae\r\n\r\n@UIApplicationMain\r\nclass AppDelegate: UIResponder, UIApplicationDelegate, UISplitViewControllerDelegate {\r\n\r\n  func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -> Bool {\r\n    // init application\r\n    ...\r\n    registerDependencies()\r\n  }\r\n  \r\n  func registerDependencies() -> Void {\r\n    let registrar = Registrar.instance\r\n    // NOTE: Implementation MUST implement the Injectable protocol\r\n    // NOTE: Currently registration is not type safe - you could register a nonconforming class\r\n    registrar.register(Swift.self, WhiteThroatedNeedleTail.self)\r\n  }\r\n}\r\n```\r\nInstances of your protocol can then be grabbed from the registrar:\r\n```swift\r\nstruct Thingy {\r\n  let swift = Registrar.instance.obtain(Swift.self) as! Swift\r\n  \r\n  func howFastAreMyBirds() -> Int {\r\n    return self.swift.airspeedVelocity()\r\n  }\r\n}\r\n```\r\nBut what if my dependencies have dependencies??  Apodidae will resolve the chained dependencies \r\nbefore providing you the implementation:\r\n```swift\r\nprotocol BirdCage: Injectable {\r\n  func howFastAreMyBirds() -> Int\r\n}\r\n\r\nstruct Thingy: BirdCage {\r\n  let swift: Swift\r\n  \r\n  static func dependencies -> [Any] {\r\n    return [\r\n      Swift.self // defines the type dependency on a swift\r\n    ]\r\n  }\r\n  \r\n  init(dependencies: [Injectable]) {\r\n    // Dependencies are returned in the same order you specified\r\n    self.swift = dependencies[0] as! Swift\r\n  }\r\n  \r\n  func howFastAreMyBirds() -> Int {\r\n    return self.swift.airspeedVelocity()\r\n  }\r\n}\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}